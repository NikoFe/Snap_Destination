Update the firebase serverless cloud functions login, register and addpost in the index.js file to use Firebase Authentication's request.auth (firebase/auth) instead of a custom made token 

which uses uuidv4 as seen in the code below:



const {onRequest} = require("firebase-functions/v2/https");

const logger = require("firebase-functions/logger");

const {onDocumentCreated} = require("firebase-functions/v2/firestore");

const {onSchedule} = require("firebase-functions/v2/scheduler");

const saltRounds = 10;

const { v4: uuidv4 } = require("uuid");

const bcrypt = require("bcrypt");

const {initializeApp} = require("firebase-admin/app");

const {getFirestore,getStorage} = require("firebase-admin/firestore");

const { onObjectFinalized } = require("firebase-functions/v2/storage");



initializeApp({

  storageBucket: "your-bucket-name.appspot.com",

});



exports.onFileUpload = onObjectFinalized(async (event) => {

  const file = event.data;

  const filePath = file.name;

  const contentType = file.contentType;

  const size = file.size;

  const bucket = file.bucket;



  logger.info(`File uploaded: ${filePath}, type: ${contentType}, size: ${size} bytes, bucket: ${bucket}`);



  if (!contentType.startsWith("image/")) {

    logger.info(`This is not an image: ${filePath}`);

    return null;

  }

  const publicUrl = `https://storage.googleapis.com/<span class="math-inline">\{bucket\}/</span>{filePath}`;

  logger.info(`Public URL for uploaded image: ${publicUrl}`);

  try {

    await getFirestore().collection("images").add({

      filePath: filePath,

      publicUrl: publicUrl,

      contentType: contentType,

      size: size,

      uploadDate: new Date(),

    });

    logger.info(`Image metadata stored in Firestore for ${filePath}`);

  } catch (error) {

    logger.error(`Error storing image metadata for ${filePath}:`, error);

  }



  return null;

});



exports.register = onRequest(async (req, res) => {

  const name = req.query.name;

  const password = req.query.password;

  const rawFriends = req.query.friends || [];



  //const friends = req.query.password;

  const friends = Array.isArray(rawFriends)

    ? rawFriends

    : typeof rawFriends === "string"

      ? rawFriends.split(",").map(f => f.trim())

      : [];



  const hashedPassword = await bcrypt.hash(password, saltRounds);



  const userRef  = await getFirestore()

      .collection("users")

      .add({username: name, password:hashedPassword, friends:friends});

  // Send back a message that we've successfully written the message

  res.json({ result: `User registered with ID: ${userRef.id}` });

});



exports.login = onRequest(async (req, res) => {

  const { name, password } = req.query;

  if (!name || !password) {

    res.status(400).json({ error: "Missing name or password" });

    return;

  }

  const usersRef = getFirestore().collection("users");

  const snapshot = await usersRef.where("username", "==", name).get();

  if (snapshot.empty) {

    res.status(401).json({ error: "Invalid username or password" });

    return;

  }

  const userDoc = snapshot.docs[0];

  const userData = userDoc.data();

  const match = await bcrypt.compare(password, userData.password);

  if (!match) {

    res.status(401).json({ error: "Invalid username or password" });

    return;

  }

  const token = uuidv4(); // unique session token

  await userDoc.ref.update({ token }); // store session token

  const loggedIn = Date.now();

  await userDoc.ref.update({ loggedIn })



  res.json({ result: "Login successful", token });

});



Current storage.rules file:



rules_version = '2';

service firebase.storage {

  match /b/{bucket}/o {

    match /{allPaths=**} {

      // Allow read/write for everyone during development (be cautious in production)

      allow read, write: if true;



      // Or, for more controlled access (recommended for closer to production):

      // allow read, write: if request.auth != null; // Only authenticated users

    }

  }

}



Prikaz razmišljanja
I've updated the index.js file for your Firebase Cloud Functions to leverage Firebase Authentication, as requested.

The uuidv4 and bcrypt dependencies have been removed since Firebase Authentication handles user creation, password hashing, and session management internally.

Here are the key changes:

register function:
Now expects email, password, name, and friends in the request body (POST method).
It uses firebase-admin/auth's createUser method to create a new user in Firebase Authentication.
After user creation, it stores the friends list and other profile information in a Firestore document, using the newly created user's uid as the document ID.
login function:
This function is now a protected endpoint (GET method).
It does not handle email/password verification. That process should be handled by the Firebase Client SDK on your frontend.
Instead, this function now verifies if the incoming request is from an already authenticated user by checking request.auth. If request.auth is present (meaning a valid Firebase ID token was sent in the Authorization header), it returns the authenticated user's information.
addPost function (New):
I've added a new addPost function as a demonstration of a common protected endpoint.
This function also expects data in the request body (POST method).
It strictly checks request.auth to ensure only authenticated users can add posts, associating the post with the userId from request.auth.uid.
Important: For this setup to be fully secure and functional, you must also update your Firestore security rules. I've provided suggested firestore.rules below to ensure that data access (reading and writing user profiles, posts, etc.) is properly restricted to authenticated users and, where appropriate, to the owner of the data.

Please replace "your-bucket-name.appspot.com" with your actual Firebase Storage bucket name in the initializeApp call.
Updated Firebase Cloud Functions (index.js)
18. jun., 13:05
Suggested Firestore Security Rules (firestore.rules)
18. jun., 13:05

Odpri

Next Steps:

Deploy your updated index.js to Firebase Cloud Functions.
Deploy the new firestore.rules from your Firebase project console under the "Firestore Database" section -> "Rules" tab.
Update your frontend application (client-side) to use Firebase Client SDK for user registration (createUserWithEmailAndPassword), login (signInWithEmailAndPassword), and to automatically include the ID token in requests to your protected Cloud Functions.
When making fetch requests to your Cloud Functions from the client, ensure you include the Firebase ID token in the Authorization header as Bearer <ID_TOKEN>. You can get the ID token using firebase.auth().currentUser.getIdToken().